// Generated by CoffeeScript 1.7.1

/*
	JavaScript Document, by 梁达俊
		aJazz full export
	version 1.0
 */
define(function(require, exports, module){
	aJazz = {};

/*
JavaScript Document, by 梁达俊
	aJazz.util util functions
version 1.0
 */
var Route, util,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

aJazz.util = {

  /*
  	convert query string to json object
  	@param  {String} str
  	@return {Object}
   */
  deparam: function(str) {
    var data, isArray, pattern, query, row, rowBody, rowHead;
    pattern = /([^&=#?]+)=([^&=#?]*)/g;
    data = {};
    query = str.replace(/\+/g, "%20");
    while (row = pattern.exec(query)) {
      rowHead = decodeURIComponent(row[1]);
      isArray = (rowHead.indexOf("[]")) > -1;
      rowHead = rowHead.replace("[]", "");
      rowBody = decodeURIComponent(row[2]);
      if (rowHead in data) {
        !(data[rowHead] instanceof Array) && (data[rowHead] = [data[rowHead]]);
        data[rowHead].push(rowBody);
      } else if (isArray) {
        data[rowHead] = [rowBody];
      } else {
        data[rowHead] = rowBody;
      }
    }
    return data;
  },

  /*
  	move object child node to another object
   */
  moveTo: function(toObj, formObj, key) {
    if (formObj[key] != null) {
      toObj[key] = formObj[key];
      return delete formObj[key];
    }
  },
  createFactory: function(Class, options) {
    return function() {
      return new Class(options);
    };
  },

  /*
  	extend from a super class
   */
  extendClass: function(params, classProp) {
    var extend, newClass;
    extend = arguments.callee;
    newClass = (function(_super) {
      __extends(newClass, _super);

      function newClass() {
        return newClass.__super__.constructor.apply(this, arguments);
      }

      newClass.extend = extend;

      return newClass;

    })(this);
    $.extend(newClass.prototype, params);
    $.extend(newClass, classProp);
    return newClass;
  },
  getFuncOrValue: function(dataItem, args, context) {
    if (args == null) {
      args = [];
    }
    if (typeof dataItem === "function") {
      return dataItem.apply(context, args);
    } else {
      return dataItem;
    }
  },

  /*
  	validate data
  	@param  {Object<message:String|pattern:RegExp|value:String>} 	options
  	@param {Boolean}		fullValidation		validate all fields or stop when get an error default:false
  	@return {Array<error:String|message:String>}       error key:error message pairs
   */
  validate: function(options, fullValidation) {
    var errors, item, key, value;
    errors = [];
    for (key in options) {
      item = options[key];
      value = item.value != null ? item.value : "";
      if (!item.pattern.test(item.value)) {
        errors.push({
          error: key,
          message: item.message
        });
        if (!fullValidation) {
          break;
        }
      }
    }
    if (errors.length > 0) {
      return errors;
    } else {
      return true;
    }
  }
};


/*
JavaScript Document, by 梁达俊
	aJazz.Map
	aJazz.CacheMap
version 1.0
 */

util = aJazz.util;


/*
Map class, basic Map
 */

aJazz.Map = (function() {
  function Map(objects) {
    this.objects = objects != null ? objects : {};
  }


  /*
  	get the item of the specified id(key) from objects,
  	if no id specified return all objects
  	@param  {String} id id(key) in objects
  	@return {}
   */

  Map.prototype.get = function(id) {
    if (id != null) {
      return this.objects[id];
    } else {
      return this.objects;
    }
  };


  /*
  	get items by the specified key=value in objects
  	if no value specified return an objects grouped by each key
  	@param  {String} byKey key
  	@param  {} 		value value
  	@return {Object}
   */

  Map.prototype.getBy = function(byKey, value) {
    var item, itemValue, key, result, _i, _len, _ref;
    result = {};
    _ref = this.objects;
    for (item = _i = 0, _len = _ref.length; _i < _len; item = ++_i) {
      key = _ref[item];
      itemValue = item[byKey];
      if (value != null) {
        result[key] = item;
      } else if (itemValue === (typeof dataItem === "function" ? value.call(this, key, item) : value)) {
        if (!(result in itemValue)) {
          result[itemValue] = {};
        }
        result[itemValue][key] = item;
      }
    }
    return result;
  };


  /*
  	set a value or values to objects with key
  	@param {String} 	key 	key
  	@param {} 		value 	value
  	or
  	@param {Object} 	values 	key:value pairs
  	@return
   */

  Map.prototype.set = function(key, value) {
    var id;
    if (typeof key === "object") {
      for (id in key) {
        value = key[id];
        this.set(id, value);
      }
    } else {
      this.objects[key] = value;
    }
    return this;
  };


  /*
  	remove a item from map, if no idObj is specified remove all data from the map
  	@param  {[type]} idObj [description]
  	@return {[type]}       [description]
   */

  Map.prototype.remove = function(idObj) {
    var type;
    type = typeof idObj;
    switch (type) {
      case "undefined":
        this.objects = {};
        break;
      case "string":
      case "number":
        delete this.objects[idObj];
        break;
      default:
        this.foreach(function(id, obj) {
          if (idObj === obj) {
            return delete this.objects[id];
          }
        });
    }
    return this;
  };


  /*
  	httpiterate throughout the map
  	http@param  {Function(key,value)}	func	function call for each iteration
  	http@return
   */

  Map.prototype.foreach = function(func) {
    var id, item, objects;
    objects = this.objects;
    for (id in objects) {
      item = objects[id];
      func.call(this, id, item);
    }
    return this;
  };

  return Map;

})();


/*
httpCacheMap class
 */

aJazz.CacheMap = (function(_super) {
  __extends(CacheMap, _super);

  function CacheMap() {
    return CacheMap.__super__.constructor.apply(this, arguments);
  }

  CacheMap.prototype.get = function(id, fallback, create) {
    var obj;
    obj = CacheMap.__super__.get.call(this, id);
    if (create && !(obj != null)) {
      obj = util.getFuncOrValue(fallback, null, this);
      this.set(id, obj);
    }
    return obj;
  };

  return CacheMap;

})(aJazz.Map);


/*
JavaScript Document, by 梁达俊
	aJazz.Config
version 1.0
 */


/*
Config class
 */

aJazz.Config = (function(_super) {
  __extends(Config, _super);

  function Config() {
    return Config.__super__.constructor.apply(this, arguments);
  }


  /*
  	pass arguments to the config function
  	@param  	{String}	key		the key for the specified config function
  	@param 	{}			value
  	...						arguments for cofig function
  	@return 	{}			resuilt returned by config function
  	or
  	@param 	{Object}	configs	key:argument pairs
  	@return 	{}			key:result of configs
   */

  Config.prototype.config = function(key, value) {
    var item, results, _ref;
    if (arguments.length === 1) {
      results = {};
      _ref = arguments[0];
      for (key in _ref) {
        item = _ref[key];
        results[key] = this.config(key, item);
      }
      return results;
    } else {
      return (this.get(key))(value);
    }
  };

  return Config;

})(aJazz.Map);


/*
Global config object, all configs must be set to this
@type {Config}
 */

aJazz.config = new aJazz.Config();


/*
JavaScript Document, by 梁达俊
	aJazz.EventDispatcher
version 1.0
 */

util = aJazz.util;


/*
EventDispatcher class
 */

aJazz.EventDispatcher = (function() {

  /*
  	event listener id, +1 for each EventDispatcher object
  	@type {Number}
   */
  EventDispatcher.listenerId = 0;

  function EventDispatcher(options) {

    /*
    		custom options bind to the EventDispatcher
    		@type {Object}
     */
    this.options = $.extend({}, this.defaultOptions, options);
    this._events = {};
    this._listenerId = EventDispatcher.listenerId++;
  }


  /*
  	default value for options
  	@type {Object}
   */

  EventDispatcher.prototype.defaultOptions = null;


  /*
  	bind event to the EventDispatcher
  	@param  {String} 			eventKey 	       	name of event
  	@param  {Function} 			listner     	    event listner function
  	@param  {EventDispatcher} 	callbackContext 	optional, "this" object in listner function
  	@return
   */

  EventDispatcher.prototype.on = function(eventKey, listner, callbackContext) {
    this._bind(eventKey, listner, callbackContext, false);
  };


  /*
  	bind event to the EventDispatcher, trigger only once
  	@param  {String} 			eventKey 	       	name of event
  	@param  {Function} 			listner     	    event listner function
  	@param  {EventDispatcher} 	callbackContext 	optional, "this" object in listner function
  	@return
   */

  EventDispatcher.prototype.one = function(eventKey, listner, callbackContext) {
    this._bind(eventKey, listner, callbackContext, true);
  };


  /*
  	unbind event by eventKey,
  	or eventKey and callbackContext,
  	or ubind all events with no param passed
  	@param  {String} 			eventKey       	 	optional, name of event
  	@param  {EventDispatcher}	callbackContext 	optional, "this" object in listner function
  	@return
   */

  EventDispatcher.prototype.off = function(eventKey, callbackContext) {
    var eventArr, events, key, _i, _len, _ref;
    events = this._events;
    switch (arguments.length) {
      case 0:
        this._events = {};
        break;
      case 1:
        if (eventKey instanceof EventDispatcher) {
          for (key in events) {
            eventArr = events[key];
            events[key] = $.grep(eventArr, function(eventItem) {
              return eventItem.callbackContext !== eventKey;
            });
          }
        } else {
          _ref = eventKey.split(",");
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            eventKey = _ref[_i];
            delete events[eventKey];
          }
        }
        break;
      default:
        events[eventKey] = $.grep(events[eventKey], function(eventItem) {
          return eventItem.callbackContext !== callbackContext;
        });
    }
  };


  /*
  	trigger an event binded
  	@param  {String} eventKey     name of event
  	@param  {}		eventDataArr data pass to the event listener
  	@param  {Object} eventOptions options for event
  	@return
   */

  EventDispatcher.prototype.trigger = function(eventKey, eventDataArr, eventOptions) {
    var callbackContext, eventArr, eventItem, eventObj, eventsByKey, result, triggerResult, _i, _j, _len, _len1, _ref;
    _ref = eventKey.split(",");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eventKey = _ref[_i];
      eventObj = eventOptions instanceof aJazz.EventObject ? eventOptions : new aJazz.EventObject(eventKey, this, eventOptions);
      eventArr = [eventObj];
      triggerResult = true;
      eventsByKey = this._events[eventKey];
      eventObj.setCurrentTarget(this);
      (eventDataArr != null) && (eventArr = eventArr.concat(eventDataArr));
      if (eventsByKey != null) {
        for (_j = 0, _len1 = eventsByKey.length; _j < _len1; _j++) {
          eventItem = eventsByKey[_j];
          callbackContext = eventItem.callbackContext;
          result = eventItem.listner.apply(callbackContext, eventArr) !== false;
          eventItem.once && this.off(eventKey, callbackContext);
          if (!result) {
            eventObj.cancelBubble();
            triggerResult = false;
          }
          eventObj.bubble && callbackContext !== this && callbackContext.trigger.call(callbackContext, eventKey, eventDataArr, eventObj);
        }
      }
    }
    return triggerResult;
  };


  /*
  	destroy the eventDispatcher, remove all events
  	@return
   */

  EventDispatcher.prototype.remove = function() {
    this.off();
  };


  /*
  	get an option from the options object, or get the options object if no key is specified
  	@param  {String}	key optional, key of the option
  	@return {}
   */

  EventDispatcher.prototype.getOption = function(key) {
    if (key != null) {
      return this.options[key];
    } else {
      return this.options;
    }
  };


  /*
  	set an option to the options object, or set the options if an object is passed
  	@event optionChange:(optionKey)
  	@event optionsChange event
  	@param {String} key key of the option
  	@param {} 		value	 	value for the option
  	@param {Boolean} trigger 	trigger optionChange events or not, default:true
  	@return
  	or
  	@param {Object} 	options 	key:value map of options to set
  	@param {Boolean} trigger 	trigger optionChange events or not, default:true
  	@return{Boolean}	options have changes or not
   */

  EventDispatcher.prototype.setOption = function() {
    var beforeChangeOption, beforeChangeOptions, changed, changedOptions, key, options, trigger, value;
    options = {};
    changedOptions = {};
    beforeChangeOptions = {};
    changed = false;
    if (typeof arguments[0] !== "object") {
      options[arguments[0]] = arguments[1];
      trigger = arguments[2] !== false;
    } else {
      options = arguments[0];
      trigger = arguments[1] !== false;
    }
    for (key in options) {
      value = options[key];
      if (this.options[key] !== value) {
        beforeChangeOption = this.options[key];
        beforeChangeOptions[key] = beforeChangeOption;
        changedOptions[key] = this.options[key] = value;
        trigger && this.trigger("optionChange:" + key, [value, beforeChangeOption], {
          bubble: false
        });
        changed = true;
      }
    }
    changed && trigger && this.trigger("optionsChange", [changedOptions, beforeChangeOptions], {
      bubble: false
    });
    return changed;
  };


  /*
  	remove any option from options
  	@param  {String} key key for the option
  	@return
   */

  EventDispatcher.prototype.removeOption = function(key) {
    delete this.options[key];
  };

  EventDispatcher.prototype._bind = function(eventKey, listner, callbackContext, once) {
    var eventsByKey, _i, _len, _ref;
    _ref = eventKey.split(",");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eventKey = _ref[_i];
      eventsByKey = this._events[eventKey];
      !(eventsByKey != null) && (eventsByKey = this._events[eventKey] = []);
      callbackContext = callbackContext || this;
      eventsByKey.push({
        listner: listner,
        callbackContext: callbackContext,
        once: once
      });
    }
  };

  return EventDispatcher;

})();


/*
event object class, carry params for events
@param  {String} 			eventKey
@param  {EventDispatcher} 	target
@param  {Boolean}			bubble
@return
 */

aJazz.EventObject = (function() {
  function EventObject(eventKey, target, options) {
    $.extend(this, options);
    this.type = eventKey;
    this.target = this.currentTarget = target;
    this.bubble = this.bubble !== false;
  }


  /*
  	set currentTarget for the event object
  	@param  {EventDispatcher} currentTarget
  	@return
   */

  EventObject.prototype.setCurrentTarget = function(currentTarget) {
    this.currentTarget = currentTarget;
  };


  /*
  	cancel event bubbling
  	@return
   */

  EventObject.prototype.cancelBubble = function() {
    return this.bubble = false;
  };

  return EventObject;

})();


/*
JavaScript Document, by 梁达俊
	aJazz.Controller
	aJazz.LocalController
	aJazz.ControllerDebugger
version 1.0
 */

util = aJazz.util;


/*
WebService Api Controller class
 */

aJazz.Controller = (function(_super) {

  /*
  	console.log ie fix
   */
  var console;

  __extends(Controller, _super);

  console = window.console || {
    log: function() {}
  };

  Controller.extend = util.extendClass;

  function Controller(options) {
    Controller.__super__.constructor.apply(this, arguments);
    util.moveTo(this, this.options, "app");
    this._requestArgs = null;
    this.response = this.defaults;
    this.$queue = $({});
    this["debugger"] && this["debugger"].add(this);
    this.init(options);
  }


  /*
  	ajax function, overwrite if needed
  	@type {Function}
   */

  Controller.prototype.ajax = $.ajax;


  /*
  	url to the webService
  	@type {String|Function}
   */

  Controller.prototype.url = "";


  /*
  	ajax request type, get or post
  	@type {String}
   */

  Controller.prototype.type = "post";


  /*
  	ajax data type
  	@type {String}
   */

  Controller.prototype.dataType = "json";


  /*
  	base url to the server, prepend to url
  	@type {String}
   */

  Controller.prototype.apiRoot = "";


  /*
  	dummy data url
  	@type {String}
   */

  Controller.prototype.dummyUrl = "";


  /*
  	base url to the dummy data, prepend to dummyUrl
  	@type {String}
   */

  Controller.prototype.dummyRoot = "";


  /*
  	use dummy data or true webservice
  	@type {Boolean}
   */

  Controller.prototype.dummyEnabled = false;


  /*
  	use ajax error text or status code for error status
  	@type {Boolean}
   */

  Controller.prototype.useStatusCodeForError = false;


  /*
  	catch errors and trigger error event
  	@type {Boolean}
   */

  Controller.prototype.catchErrors = true;


  /*
  	ajax timeout
  	@type {Number}
   */

  Controller.prototype.timeout = 0;


  /*
  	the unique controller debugger for debugging
  	@type {aJazz.ControllerDebugger}
   */

  Controller.prototype["debugger"] = null;


  /*
  	default value of response before send is call
  	@type {Object}
   */

  Controller.prototype.defaults = null;


  /*
  	headers for request
  	@type {Object|Function}
   */

  Controller.prototype.headers = null;


  /*
  	send a request
  	@event  send
  	@event  error
  	@event  error:requestValidation
  	@param  {Object} 	data 	data send to server
  	@param  {String} 	type 	request type such as get post put delete
  	@param  {String} 	eventAffix 	request success event affix triggers success:{eventAffix} if given
  	@return {XMLHttpRequest}    	XMLHttpRequest Object for the request
   */

  Controller.prototype.send = function(data, type, eventAffix) {
    var args;
    if (type == null) {
      type = this.type;
    }
    args = arguments;
    this._try(function() {
      var eventObj, request, validateResult;
      request = this.process(data);
      validateResult = this.validateRequest(request);
      if (validateResult === true) {
        this._requestArgs = args;
        this.trigger("send", request);
        this.$queue.queue("ajax", (function(_this) {
          return function(next) {
            _this.ajax({
              url: _this.dummyEnabled ? _this.dummyRoot + _this.dummyUrl : _this.apiRoot + util.getFuncOrValue(_this.url, [request], _this),
              type: _this.dummyEnabled ? "get" : type,
              headers: util.getFuncOrValue(_this.headers, [request], _this),
              data: request,
              dataType: _this.dataType,
              timeout: timeout
            }).done(function(response) {
              _this._success(response, eventAffix);
            }).fail(function(xhr, status) {
              _this._error(xhr, status, eventAffix);
            }).always(function(xhr, status) {
              _this._complete(xhr, status, eventAffix);
              next();
            });
          };
        })(this));
        if ((this.$queue.queue("ajax")).length === 1) {
          this.$queue.dequeue("ajax");
        }
      } else {
        eventObj = {
          status: "requestValidation"
        };
        this.trigger("error:requestValidation,error", validateResult, eventObj);
      }
    });
    return this;
  };


  /*
  	retry the last request
  	@return
   */

  Controller.prototype.retry = function() {
    this._requestArgs && this.send.apply(this, this._requestArgs);
    return this;
  };

  Controller.prototype.init = function(options) {};


  /*
  	process data before send
  	@param  {Object} data the unprocess request data
  	@return {Object}      processed data
   */

  Controller.prototype.process = function(data) {
    return data;
  };


  /*
  	parse data after response
  	@param  {Object} data the unparsed response data
  	@return {Object}      parseed data
   */

  Controller.prototype.parse = function(data) {
    return data;
  };


  /*
  	validate the processed request data
  	@return {Boolean|Object} return true if validate passed, else return an custom error object
   */

  Controller.prototype.validateRequest = function() {
    return true;
  };


  /*
  	validate the parsed response data
  	@return {Boolean|Object} return true if validate passed, else return an custom error object
   */

  Controller.prototype.validateResponse = function() {
    return true;
  };

  Controller.prototype._try = function(func) {
    var e;
    if (this.catchErrors) {
      try {
        return func.call(this);
      } catch (_error) {
        e = _error;
        console.log(e.stack);
        return this.trigger("error");
      }
    } else {
      return func.call(this);
    }
  };


  /*
  	ajax success callbacks
  	@param  {Object} response ajax response data
  	@param  {String} 	eventAffix 	request success event affix triggers success:{eventAffix} if given
  	@return
   */

  Controller.prototype._success = function(response, eventAffix) {
    this._try(function() {
      var data, eventObj, validateResult;
      data = this.parse(response);
      validateResult = this.validateResponse(data);
      if (validateResult === true) {
        this.response = data;
        this.trigger("success", [data]);
        if (eventAffix != null) {
          this.trigger("success:" + eventAffix, [data]);
        }
      } else {
        eventObj = {
          status: "responseValidation"
        };
        this.trigger("error:responseValidation,error", validateResult, eventObj);
      }
    });
  };


  /*
  	ajax error callback
  	@param  {XMLHttpRequest} xhr
  	@param  {String} 		errorType	ajax error type
  	@return
   */

  Controller.prototype._error = function(xhr, status, eventAffix) {
    var e, eventObj, response, resultStatus;
    response = xhr.response;
    eventObj = {
      status: xhr.status
    };
    resultStatus = this.useStatusCodeForError ? xhr.status : status;
    if (this.dataType === "json") {
      try {
        response = $.parseJSON(response);
      } catch (_error) {
        e = _error;
        console.log(e);
      }
    }
    this.trigger("error:" + resultStatus + ",error", [response], eventObj);
    if (eventAffix != null) {
      this.trigger("error:" + eventAffix, [response], eventObj);
    }
  };


  /*
  	ajax complete callback
  	@return
   */

  Controller.prototype._complete = function() {
    this.trigger("complete");
  };

  return Controller;

})(aJazz.EventDispatcher);


/*
localStorage Controller
 */

aJazz.LocalController = (function(_super) {
  __extends(LocalController, _super);

  LocalController.extend = util.extendClass;

  function LocalController(options) {
    LocalController.__super__.constructor.apply(this, arguments);
    this.response = this._read();
    this["debugger"] && this["debugger"].add(this);
    this.init(options);
  }


  /*
  	set @unique key to read and write localStorage data
  	@type {String}
   */

  LocalController.prototype.url = "";


  /*
  	the unique controller debugger for debugging
  	@type {aJazz.ControllerDebugger}
   */

  LocalController.prototype["debugger"] = null;


  /*
  	catch errors and trigger error event
  	@type {Boolean}
   */

  LocalController.prototype.catchErrors = true;


  /*
  	default value of response before send is call
  	@type {Object|Function}
   */

  LocalController.prototype.defaults = null;


  /*
  	save data to local
  	@event success
  	@return
   */

  LocalController.prototype.send = function(data) {
    this._try(function() {
      var localData, url, validateResult;
      localData = {};
      url = util.getFuncOrValue(this.url, [data], this);
      localData.data = this.process(data);
      validateResult = this.validateRequest(localData.data);
      if (validateResult === true) {
        localStorage.setItem(url, JSON.stringify(localData));
        this.response = data;
        this.trigger("send,success", data);
      } else {
        this.trigger("error:requestValidation,error", validateResult);
      }
    });
    return this;
  };


  /*
  	process data before send
  	@param  {Object} data the unprocess request data
  	@return {Object}      processed data
   */

  LocalController.prototype.process = function(data) {
    return data;
  };


  /*
  	remove the controller
  	@return
  	remove: ->
  		@app? && @app.off @
  		super
   */


  /*
  	initialize
  	@param  {Object} options
  	@return
   */

  LocalController.prototype.init = function(options) {};


  /*
  	validate the data being save
  	@param  {Object} data
  	@return {Boolean}
   */

  LocalController.prototype.validateRequest = function() {
    return true;
  };

  LocalController.prototype._try = aJazz.Controller.prototype._try;


  /*
  	read data from local into memory, only once before init
  	@return {Object}
   */

  LocalController.prototype._read = function() {
    var dataStr, localData, url;
    localData = {
      data: util.getFuncOrValue(this.defaults, [], this)
    };
    url = util.getFuncOrValue(this.url);
    dataStr = localStorage.getItem(url);
    if (dataStr != null) {
      this._try(function() {
        return localData = $.parseJSON(dataStr);
      });
    }
    return localData.data;
  };

  return LocalController;

})(aJazz.EventDispatcher);


/*
Controller Debugger
 */

aJazz.ControllerDebugger = (function(_super) {
  __extends(ControllerDebugger, _super);

  function ControllerDebugger() {
    return ControllerDebugger.__super__.constructor.apply(this, arguments);
  }


  /*
  	json or string, string will log the stringify result of json
  	@type {String}
   */

  ControllerDebugger.prototype.debugType = "json";


  /*
  	assign a controller to the debugger
  	@param  {Controller} controller the controller to debug
  	@return
   */

  ControllerDebugger.prototype.add = function(controller) {
    controller.on("send,success,error", this._debug, this);
    return this;
  };

  ControllerDebugger.prototype._debug = function(e) {
    var args;
    args = [e.type].concat(Array.prototype.slice.call(arguments, 1));
    switch (this.debugType) {
      case "string":
        args = [JSON.stringify(args)];
    }
    console.log.apply(console, args);
  };

  return ControllerDebugger;

})(aJazz.EventDispatcher);

aJazz.config.set({

  /*
  	set up apiRoot for all controllers
  	@param  {String} apiRoot
  	@return
   */
  "apiRoot": function(apiRoot) {
    return aJazz.Controller.prototype.apiRoot = apiRoot;
  },

  /*
  	set up dummyRoot for all controllers
  	@param  {String} dummyRoot
  	@return
   */
  "dummyRoot": function(dummyRoot) {
    return aJazz.Controller.prototype.dummyRoot = dummyRoot;
  },

  /*
  	set up dummyEnabled for all controllers
  	@param  {String} dummyEnabled
  	@return
   */
  "dummyEnabled": function(dummyEnabled) {
    return aJazz.Controller.prototype.dummyEnabled = dummyEnabled;
  },

  /*
  	timeout for all ajax requests
  	@param  {Number} timeout
  	@return
   */
  "timeout": function(timeout) {
    return aJazz.Controller.prototype.timeout = timeout;
  },

  /*
  	set up useStatusCodeForError for all controllers
  	@param  {Boolean} useStatusCodeForError
  	@return
   */
  "useStatusCodeForError": function(useStatusCodeForError) {
    return aJazz.Controller.prototype.useStatusCodeForError = useStatusCodeForError;
  },

  /*
  	whether console debugging for all controllers is enabled
  	@param  {Boolean} debug
  	@return
   */
  "debug": function(debug) {
    return aJazz.Controller.prototype["debugger"] = aJazz.LocalController.prototype["debugger"] = debug ? new aJazz.ControllerDebugger() : null;
  },

  /*
  	debugType for console debugging
  	@param  {String} debugType
  	@return
   */
  "debugType": function(debugType) {
    return aJazz.ControllerDebugger.prototype.debugType = debugType;
  },

  /*
  	catch errors and trigger error event instead of throwing error to top
  	@param  {String} catchErrors
  	@return
   */
  "catchErrors": function(catchErrors) {
    return aJazz.Controller.prototype.catchErrors = aJazz.LocalController.prototype.catchErrors = catchErrors;
  }
});


/*
JavaScript Document, by 梁达俊
	aJazz.View
	aJazz.TransView
version 1.0
 */

util = aJazz.util;

aJazz.View = (function(_super) {
  __extends(View, _super);


  /*
  	 * the css class for hiding elements
  	 * @type {String}
   */

  View.HIDDEN_CLS = "hidden";


  /*
  	 * extent this class into a child class
  	 * @type {Function}
   */

  View.extend = util.extendClass;

  function View(options) {
    var $ele, CacheMap;
    View.__super__.constructor.apply(this, arguments);

    /*
    		 * @var {aJazz.View}	parent view of this view, set with the parent view set view method
     */
    this.parent = null;
    $ele = this.$ele = this.id != null ? $(document.getElementById(this.id)) : ($(document.createElement(this.tagName))).addClass(this.className);
    $ele.data("view", this);
    util.moveTo(this, this.options, "app");
    util.moveTo(this, this.options, "route");
    CacheMap = aJazz.CacheMap;
    this._viewMap = new CacheMap();
    this._controllerMap = new CacheMap(this.options.controllers);
    delete this.options.controllers;
    this._inserted = false;
    this._domEvents = {};
    delete this.options.controllers;
    this.init();
    if (this.options.viewport != null) {
      this.appendTo(this.options.viewport);
    }
  }


  /*
  	 * id for the view element
  	 * if specified, find dom element by id as @$ele, and do not create a new element according to classname and tagname
  	 * @type {String}
   */

  View.prototype.id = null;


  /*
  	 * class name for the view element
  	 * @type {String}
   */

  View.prototype.className = "";


  /*
  	 * tag name for the view element
  	 * @type {String}
   */

  View.prototype.tagName = "div";


  /*
  	 * auto call render before init
  	 * @type {Boolean}
   */

  View.prototype.autoRender = true;


  /*
  	 * template function
  	 * @type {Function}
   */

  View.prototype.template = function() {
    return "";
  };


  /*
  	 * dom events, define as "event[|selector|elementSelector]"
  	 * @type {Object<Function>}
   */

  View.prototype.events = {};


  /*
  	 * data render functions as func(data, $element)
  	 * @type {Object<Function>}
   */

  View.prototype.binders = {};


  /*
  	 * public constructor, call after base view class _construct
  	 * @param  {Object} options
  	 * @return
   */

  View.prototype.init = function(options) {};


  /*
  	 * append the view element to the viewport element
  	 * @param  {Dom Object|aJazz.View} viewport the viewport element to append
  	 * @return {View}		@view
   */

  View.prototype.appendTo = function(div) {
    this._insert("append", div);
    return this;
  };

  View.prototype.beforeTo = function(div) {
    this._insert("before", div);
    return this;
  };

  View.prototype.afterTo = function(div) {
    this._insert("after", div);
    return this;
  };

  View.prototype.replaceTo = function(div) {
    this._insert("replaceWith", div);
    return this;
  };


  /*
  	 * add event listener to dom
  	 * @param  {String} 	eventKey
  	 * @param  {Function} 	listener
  	 * @return
   */

  View.prototype.addEvent = function(eventKey, listener) {
    var eventObj;
    eventObj = {};
    if (typeof eventKey === "object") {
      eventObj = eventKey;
    } else {
      eventObj[eventKey] = listener;
    }
    this._bindEvents(eventObj, true);
  };


  /*
  	 * remove event listener from dom
  	 * if no eventKey specified, remove all dom event in @view
  	 * @param  {String} 	eventKey
  	 * @return
   */

  View.prototype.removeEvent = function(eventKey) {
    var eventObj;
    eventObj = {};
    if (eventKey != null) {
      eventObj[eventKey] = this._domEvents[eventKey];
    } else {
      eventObj = this._domEvents;
    }
    this._bindEvents(eventObj, false);
  };


  /*
  	 * show the view element
  	 * @return {View}		@view
   */

  View.prototype.show = function() {
    this.$ele.removeClass(View.HIDDEN_CLS);
    return this;
  };


  /*
  	 * hide the view element
  	 * @return {View}		@view
   */

  View.prototype.hide = function() {
    this.$ele.addClass(View.HIDDEN_CLS);
    return this;
  };


  /*
  	 * switch from @view to the view specified
  	 * @return {View}		@view
   */

  View.prototype["switch"] = function(view) {
    if (view !== this) {
      view.show();
      this.hide();
    }
    return this;
  };


  /*
  	 * render the view, set the html to view element
  	 * @return
   */

  View.prototype.render = function() {
    if (this._inserted) {
      this.removeEvent();
      this.removeView();
    }
    this.$ele.html(this.template({
      view: this
    }));
    this.addEvent(this.events);
    return this;
  };


  /*
  	 * render the apart of view, fill in html and className
  	 * @param  {String} selector   	selector of the part to render
  	 * @param  {Boolean} append   	use append instead of replacing html
  	 * @return
   */

  View.prototype.render$ = function(selector, append) {
    var $div, $renderDivs, method;
    $div = $(this.template({
      view: this
    }));
    $renderDivs = ($div.filter(selector)).add($div.find(selector));
    method = append ? "append" : "html";
    (this.$(selector, true)).each(function(i) {
      var $renderDiv;
      $renderDiv = $renderDivs.eq(i);
      this.className = $renderDiv[0].className;
      return ($(this))[method]($renderDiv.html());
    });
    return this;
  };


  /*
  	 * remove the view element from Dom and unbind all events
  	 * @return
   */

  View.prototype.remove = function() {
    var bindKey;
    View.__super__.remove.apply(this, arguments);
    this.removeEvent();
    this.removeView();
    this.removeController();
    this.app && this.app.off(this);
    this.parent && this.parent._viewMap.remove(this);
    bindKey = this.$ele.attr("_view");
    if (bindKey != null) {
      this.$ele.after("<div _view='" + bindKey + "'/>");
    }
    (this.$ele.removeData("view")).remove();
    return View.__super__.remove.apply(this, arguments);
  };


  /*
  	 * send data to a render in binders to update a part of the view
  	 * @param  {String} key   	render key in binders
  	 * @param  {} 		value 	the data to render
  	 * @return
  	 * or
  	 * @param  {Object} dataMap key:value pairs to render
  	 * @return
   */

  View.prototype.bindData = function(key, value) {
    var $bind, data, render, textValue, _results;
    data = arguments[0];
    if (arguments.length > 1) {
      render = this.binders[key];
      $bind = this.$("[_bind='" + key + "']");
      textValue = typeof render === "function" ? render.call(this, value, $bind) : value;
      return this._setValue($bind, textValue);
    } else {
      _results = [];
      for (key in data) {
        value = data[key];
        _results.push(this.bindData(key, value));
      }
      return _results;
    }
  };


  /*
  	 * dom selection inside the view
  	 * @param  {[type]}		selector 	css selector
  	 * @return {$Object}
   */

  View.prototype.$ = function(selector) {
    return this.$ele.find(selector);
  };


  /*
  	 * get a child view
  	 * @param  {String} 	viewKey  	key for the child view
  	 * @param  {Object} 	fallback 	fallback options to create when fail to get
  	 * @param  {Boolean}	create  	whether to create a new view if fail to get
  	 * @return {View}
   */

  View.prototype.getView = function(viewKey, fallback, create) {
    return this._viewMap.get(viewKey, fallback, create);
  };


  /*
  	 * set one child views to @view, or set up batch of child views using childOptions and Views
  	 * @param  {String} 	viewKey     	key for @view, can used for get and remove
  	 * @param  {View} 		view        	the child view to set
  	 * @param  {Boolean} 	bind        	whether to call the bindView method using viewKey and now for @child view
  	 * @param  {Object} 	bindOptions 	options of view.switch
  	 * or
  	 * @param  {Object} 	childViews		key view pairs
  	 * @param  {Boolean} 	bind        	whether to call the bindView method using viewKey and now for @child view
  	 * @return
   */

  View.prototype.setView = function(viewKey, view, bind, bindOptions) {
    var currView, key;
    if ((typeof viewKey === "object" ? view : bind)) {
      this.bindView(viewKey, view, bindOptions);
    }
    if (typeof viewKey === "object") {
      for (key in viewKey) {
        view = viewKey[key];
        view.parent = this;
        if (currView = this._viewMap.get(key)) {
          currView.remove();
        }
      }
    } else {
      view.parent = this;
      currView = this._viewMap.get(viewKey);
      if (currView && currView !== view) {
        currView.remove();
      }
    }
    return this._viewMap.set(viewKey, view);
  };


  /*
  	 * append a view to element, and switch from the current view
  	 * @param  {String} 	bindKey 	_view attribute of element being appended to
  	 * @param  {View} 		view    	the view to append
  	 * @param  {Object} 	options 	options for view switching
  	 * @return {View} 		the appendding view
  	 * or
  	 * @param  {Object} 	childViews	key view pairs
  	 * @param  {Object} 	options 	options for view switching
   */

  View.prototype.bindView = function(bindKey, view, options) {
    var $view, currView, key;
    if (typeof bindKey === "object") {
      for (key in bindKey) {
        this.bindView(key, bindKey[key], view);
      }
    } else {
      $view = this.$("[_view='" + bindKey + "']", true);
      currView = $view.data("view");
      view.afterTo($view);
      $view.removeAttr("_view");
      view.$ele.attr("_view", bindKey);
      if (currView != null) {
        currView["switch"](view, options);
      } else {
        view.replaceTo($view);
        if (!view.visible()) {
          view.show();
        }
      }
    }
    return this;
  };


  /*
  	 * remove a child view, if no viewKey specified, remove all child views
  	 * @param  {String} 	viewKey 	key for the view to remove
  	 * @return
   */

  View.prototype.removeView = function(viewKey) {
    this._removeFromMap(this._viewMap, viewKey, true);
    return this;
  };


  /*
  	 * get a controller set to the view
  	 * @param  {String} 	controllerKey 	key for the controller
  	 * @param  {Object} 	fallback      	fallback options to create when fail to get
  	 * @param  {Boolean} 	create     		whether to create a new controller if fail to get
  	 * @return {Controller}
   */

  View.prototype.getController = function(controllerKey, fallback, create) {
    return this._controllerMap.get(controllerKey, fallback, create);
  };


  /*
  	 * set one or more controller to the view
  	 * @param  {String} 	controllerKey key
  	 * @param  {Controller} controller
  	 * or
  	 * @param {Object}		key:value pairs
  	 * @return
   */

  View.prototype.setController = function(controllerKey, controller) {
    return this._controllerMap.set(controllerKey, controller);
  };


  /*
  	 * remove a controller
  	 * @param  {String} controllerKey
   */

  View.prototype.removeController = function(controllerKey) {
    this._removeFromMap(this._controllerMap, controllerKey);
    return this;
  };


  /*
  	 * is view visible
  	 * @return {Boolean}
   */

  View.prototype.visible = function() {
    return (this.$ele.css("display")) !== "none";
  };


  /*
  	 * insert the view element into dom
  	 * @param  {String} method jQuery dom method
  	 * @param  {Dom} 	div    element to refer
  	 * @return
   */

  View.prototype._insert = function(method, div) {
    var $div, $ele;
    $ele = this.$ele;
    $div = div.$ele || $(div);
    $div[method]($ele);
    if (!this._inserted) {
      if (this.autoRender) {
        this.render();
      }
      this._inserted = true;
    }
  };


  /*
  	 * bind Dom events to element, events:view.events, isBind:Boolean
  	 * @param  {Object<Function>}  	events event defination object
  	 * @param  {Boolean} 			isBind bind or unbind events
  	 * @return
   */

  View.prototype._bindEvents = function(events, isBind) {
    var $ele, args, eventArr, fun, item, key;
    fun = isBind !== false ? "on" : "off";
    for (key in events) {
      item = events[key];
      eventArr = key.split("|");
      args = [eventArr[0]];
      $ele = eventArr.length > 1 && eventArr[1].length > 0 ? this.$(eventArr[1]) : this.$ele;
      if (isBind) {
        eventArr.length > 2 && args.push(eventArr[2]);
        args.push($.proxy(item, this));
        this._domEvents[key] = item;
      } else {
        delete this._domEvents[key];
      }
      $ele[fun].apply($ele, args);
    }
  };


  /*
  	 * set string value to element
  	 * @param {$Object} $ele  $element to set
  	 * @param {} 		value
   */

  View.prototype._setValue = function($ele, value) {
    value = value != null ? value.toString() : "";
    $ele.each(function() {
      $ele = $(this);
      switch ($ele.prop("tagName")) {
        case "INPUT":
        case "SELECT":
          switch ($ele.attr("type")) {
            case "checkbox":
            case "radio":
              $ele.prop("checked", $ele.val() === value ? "checked" : "");
              break;
            default:
              $ele.val(value);
          }
          break;
        case "IMG":
        case "IFRAME":
          $ele.attr("src", value);
          break;
        default:
          $ele.html(value);
      }
    });
  };

  View.prototype._removeFromMap = function(map, key, isView) {
    var item;
    if (key != null) {
      item = map.get(key);
      if (item != null) {
        if (isView) {
          item.parent = null;
          item.remove();
        } else {
          item.off(this);
        }
        map.remove(key);
      }
    } else {
      map.foreach((function(_this) {
        return function(key, item) {
          return _this._removeFromMap(map, key, isView);
        };
      })(this));
    }
  };

  return View;

})(aJazz.EventDispatcher);


/*
JavaScript Document, by 梁达俊
	aJazz.App
	hash format is like a query string: #page:id=123&a=csd
version 1.0
 */

util = aJazz.util;


/*
App class, global view and hash router
 */

aJazz.App = (function(_super) {
  __extends(App, _super);

  App.extend = util.extendClass;

  function App(options) {
    App.__super__.constructor.apply(this, arguments);
    this._ignoreHashChangeOnce = false;
    this.currRouteKey = null;
    this.pendingRouteKey = null;
    util.moveTo(this, this.options, "viewport");
  }


  /*
  	@type {Object<Route>}	router settings
   */

  App.prototype.routes = {};


  /*
  	start listening to hash change and go to current hash
  	@return
   */

  App.prototype.startHistory = function() {
    if (!("onhashchange" in window)) {
      this._currHash = window.location.hash;
      setInterval((function(_this) {
        return function() {
          var hash;
          hash = window.location.hash;
          if (hash !== _this._currHash) {
            _this._hashChange();
            _this._currHash = hash;
          }
        };
      })(this), 250);
    }
    ($(window)).on("hashchange.aJazz_" + this._listenerId, $.proxy(this._hashChange, this));
    return this._toRoute();
  };


  /*
  	remove the app
   */

  App.prototype.remove = function() {
    ($(window)).off(".aJazz_" + this._listenerId);
    return App.__super__.remove.apply(this, arguments);
  };


  /*
  	go to a hash
  	@param  {String|Object<route:String,query:Object>} 	hash    hash string:#... or object
  	@param  {Boolean} 		trigger		trigger router enter and exit or not
  	@return
   */

  App.prototype.goTo = function(hash, trigger) {
    var toHash;
    if (trigger == null) {
      trigger = true;
    }
    toHash = hash;
    typeof hash === "object" && (toHash = hash.route + (hash.query != null ? ":" + $.param(hash.query) : ""));
    if ((toHash.replace("#", "")) !== window.location.hash.replace("#", "")) {
      this._ignoreHashChangeOnce = true;
      window.location.hash = toHash;
      trigger && this._toRoute(toHash);
    }
  };


  /*
  	go back in history
  	@param  {Number} step how many step of history to go back
  	@return
   */

  App.prototype.goBack = function(step) {
    typeof step === "undefined" && (step = 1);
    return history.go(-step);
  };

  App.prototype._hashChange = function(e) {
    return !this._ignoreHashChangeOnce && this._toRoute();
  };

  App.prototype._toRoute = function(hash) {
    var hashArr, query, route, routeKey;
    if (hash == null) {
      hash = window.location.hash.replace("#", "");
    }
    hashArr = hash.split(":");
    routeKey = hashArr[0];
    query = util.deparam(hashArr[1] || "");
    route = this.routes[routeKey];
    this._ignoreHashChangeOnce = false;
    this.pendingRouteKey = routeKey;
    if (typeof route === "string") {
      require.async(route, (function(_this) {
        return function(route) {
          _this.routes[routeKey] = route;
          return _this._switchRoute(routeKey, query);
        };
      })(this));
    } else {
      this._switchRoute(routeKey, query);
    }
  };

  App.prototype._switchRoute = function(routeKey, query) {
    var currRoute, forward, route;
    route = this.routes[routeKey];
    currRoute = this.routes[this.currRouteKey];
    forward = route != null ? (route.compareTo(currRoute)) >= 0 : true;
    if (this.pendingRouteKey === routeKey) {
      this.trigger("routeExit", [this.currRouteKey, query, forward]);
      currRoute && currRoute.exit && currRoute.exit(this, forward);
      this.currRouteKey = this.pendingRouteKey;
      this.trigger("routeEnter", [routeKey, query, forward]);
      route && route.enter && route.enter(this, query, forward);
      this.pendingRouteKey = null;
    }
  };

  return App;

})(aJazz.View);


/*
Route class
enter: route enter function
exit: route exit function
level: the level of route, app will go forward if new level>current level
@param {Object} options {enter:Function,exit:Function,level:Number}
 */

aJazz.Route = Route = (function() {
  Route.extend = util.extendClass;

  Route.prototype.level = 0;

  function Route(options) {
    $.extend(this, options);
    this._state = null;
    this.init();
  }


  /*
  	get history state store in ths route object
  	@return {Object}
   */

  Route.prototype.getState = function() {
    return this._state;
  };


  /*
  	set history state to ths route object
  	@return {Object}
   */

  Route.prototype.setState = function(state) {
    return this._state = state;
  };


  /*
  	compare which route has the higher level to determine if history is going forward
  	@param  {Route} 	route another route to compare
  	@return {Number}
   */

  Route.prototype.compareTo = function(route) {
    if (route != null) {
      return this.level - route.level;
    } else {
      return 0;
    }
  };

  Route.prototype.init = function(options) {};

  return Route;

})();


/*
	JavaScript Document, by 梁达俊
		aJazz full export
	version 1.0
 */

return aJazz});
